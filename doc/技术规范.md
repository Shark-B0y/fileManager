# æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ - æŠ€æœ¯è§„èŒƒ

## ğŸ“‹ æ¦‚è¿°

æœ¬è§„èŒƒå®šä¹‰äº†ä½¿ç”¨ **Rust + Tauri + TypeScript** æŠ€æœ¯æ ˆå¼€å‘æ–‡ä»¶ç®¡ç†ç³»ç»Ÿçš„ç¼–ç æ ‡å‡†ã€å‘½åçº¦å®šã€æ–‡ä»¶ç»„ç»‡å’Œæœ€ä½³å®è·µã€‚

## ğŸ¯ ç›®æ ‡

1. ä¿æŒä»£ç ä¸€è‡´æ€§ï¼Œæé«˜å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
2. éµå¾ª Rust å’Œ TypeScript ç¤¾åŒºæœ€ä½³å®è·µ
3. ç¡®ä¿å›¢é˜Ÿåä½œæ•ˆç‡
4. ä¾¿äºä»£ç å®¡æŸ¥å’Œè‡ªåŠ¨åŒ–æ£€æŸ¥

## ğŸ—ï¸ é¡¹ç›®ç»“æ„è§„èŒƒ

### 1. æ•´ä½“é¡¹ç›®ç»“æ„
```
file-manager/
â”œâ”€â”€ src-tauri/                    # Ruståç«¯ä»£ç 
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs              # åº”ç”¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ commands.rs          # Tauriå‘½ä»¤å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ models/              # æ•°æ®æ¨¡å‹ï¼ˆé¢†åŸŸæ¨¡å‹ï¼‰
â”‚   â”‚   â”œâ”€â”€ services/            # ä¸šåŠ¡æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ database/            # æ•°æ®åº“å±‚
â”‚   â”‚   â”œâ”€â”€ system/              # ç³»ç»Ÿæ¥å£å±‚
â”‚   â”‚   â””â”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ Cargo.toml               # Rustä¾èµ–é…ç½®
â”‚   â”œâ”€â”€ tauri.conf.json          # Tauriåº”ç”¨é…ç½®
â”‚   â””â”€â”€ build.rs                 # æ„å»ºè„šæœ¬
â”œâ”€â”€ src/                         # å‰ç«¯ä»£ç ï¼ˆTypeScript/Reactï¼‰
â”‚   â”œâ”€â”€ main.tsx                 # åº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ App.tsx                  # ä¸»ç»„ä»¶
â”‚   â”œâ”€â”€ components/              # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ pages/                   # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ stores/                  # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ services/                # å‰ç«¯æœåŠ¡
â”‚   â”œâ”€â”€ types/                   # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ styles/                  # æ ·å¼æ–‡ä»¶
â”‚   â””â”€â”€ utils/                   # å·¥å…·å‡½æ•°
â””â”€â”€ ...                          # é…ç½®æ–‡ä»¶
```

### 2. ç›®å½•å‘½åè§„èŒƒ
- **å°å†™å­—æ¯**ï¼Œä½¿ç”¨è¿å­—ç¬¦åˆ†éš”ï¼š`src-tauri`, `database-migrations`
- **å¤æ•°å½¢å¼**ï¼š`models`, `services`, `components`
- **æ˜ç¡®å«ä¹‰**ï¼šé¿å…ä½¿ç”¨ `utils`, `helpers` ç­‰æ¨¡ç³Šåç§°

## ğŸ”¤ å‘½åè§„èŒƒ

### 1. Rust å‘½åè§„èŒƒ

#### 1.1 æ–‡ä»¶å‘½å
- **è›‡å½¢å‘½åæ³•**ï¼ˆsnake_caseï¼‰ï¼š`file_service.rs`, `tag_repository.rs`
- **æ¨¡å—æ–‡ä»¶**ï¼š`mod.rs`ï¼ˆRust 2018 é£æ ¼ä½¿ç”¨ç›®å½•åï¼‰

#### 1.2 ç±»å‹å‘½å
- **ç»“æ„ä½“/æšä¸¾**ï¼šå¤§é©¼å³°å‘½åæ³•ï¼ˆPascalCaseï¼‰
  ```rust
  struct FileMetadata { ... }
  enum FileChangeType { ... }
  trait FileService { ... }
  ```

#### 1.3 å˜é‡å’Œå‡½æ•°å‘½å
- **å˜é‡/å­—æ®µ**ï¼šè›‡å½¢å‘½åæ³•ï¼ˆsnake_caseï¼‰
  ```rust
  let file_path: String;
  let is_active: bool;

  struct FileInfo {
      file_hash: String,
      current_path: String,
  }
  ```

- **å‡½æ•°/æ–¹æ³•**ï¼šè›‡å½¢å‘½åæ³•ï¼ˆsnake_caseï¼‰
  ```rust
  fn calculate_file_hash(path: &str) -> Result<String>;
  async fn add_tag_to_file(file_path: &str, tag_name: &str) -> Result<bool>;
  ```

#### 1.4 å¸¸é‡å‘½å
- **å…¨å¤§å†™**ï¼Œä¸‹åˆ’çº¿åˆ†éš”
  ```rust
  const MAX_FILE_SIZE: u64 = 1024 * 1024 * 1024; // 1GB
  const DEFAULT_SCAN_INTERVAL: Duration = Duration::from_secs(300);
  ```

#### 1.5 ç”Ÿå‘½å‘¨æœŸå‚æ•°
- **ç®€çŸ­æè¿°æ€§**ï¼š`'a`, `'ctx`, `'db`
  ```rust
  struct FileCache<'a> {
      data: &'a [u8],
  }
  ```

### 2. TypeScript/React å‘½åè§„èŒƒ

#### 2.1 æ–‡ä»¶å‘½å
- **ç»„ä»¶æ–‡ä»¶**ï¼šå¤§é©¼å³°å‘½åæ³•ï¼Œ`.tsx` æ‰©å±•å
  ```
  FileList.tsx
  TagPanel.tsx
  SearchBar.tsx
  ```

- **å·¥å…·æ–‡ä»¶**ï¼šå°é©¼å³°å‘½åæ³•ï¼Œ`.ts` æ‰©å±•å
  ```
  fileService.ts
  tagStore.ts
  formatters.ts
  ```

#### 2.2 ç±»å‹å‘½å
- **æ¥å£/ç±»å‹åˆ«å**ï¼šå¤§é©¼å³°å‘½åæ³•ï¼Œ`I` å‰ç¼€å¯é€‰
  ```typescript
  interface FileInfo {
      path: string;
      size: number;
      type: string;
  }

  type SearchQuery = {
      tags: string[];
      operator: 'AND' | 'OR';
  };
  ```

#### 2.3 å˜é‡å’Œå‡½æ•°å‘½å
- **å˜é‡/å¸¸é‡**ï¼šå°é©¼å³°å‘½åæ³•
  ```typescript
  const fileList: FileInfo[] = [];
  let isLoading = false;

  // å¸¸é‡ä½¿ç”¨å…¨å¤§å†™
  const MAX_RESULTS = 100;
  const DEFAULT_TAG_COLOR = '#3B82F6';
  ```

- **å‡½æ•°/æ–¹æ³•**ï¼šå°é©¼å³°å‘½åæ³•
  ```typescript
  function calculateFileSize(bytes: number): string { ... }
  async function searchFiles(query: SearchQuery): Promise<SearchResult> { ... }
  ```

#### 2.4 ç»„ä»¶å‘½å
- **Reactç»„ä»¶**ï¼šå¤§é©¼å³°å‘½åæ³•
  ```typescript
  const FileList: React.FC<FileListProps> = ({ files }) => { ... };

  // å‡½æ•°ç»„ä»¶
  function TagPanel({ tags, onSelect }: TagPanelProps) { ... }
  ```

#### 2.5 CSSç±»åå‘½å
- **BEMé£æ ¼** æˆ– **Tailwind CSS**
  ```css
  /* BEMé£æ ¼ */
  .file-list { ... }
  .file-list__item { ... }
  .file-list__item--selected { ... }

  /* Tailwind CSSï¼ˆæ¨èï¼‰ */
  <div className="flex flex-col gap-4 p-4 bg-white rounded-lg shadow">
  ```

## ğŸ“ ä»£ç æ³¨é‡Šè§„èŒƒ

### 1. Rust æ³¨é‡Šè§„èŒƒ

#### 1.1 æ–‡æ¡£æ³¨é‡Šï¼ˆ///ï¼‰
- **å…¬å…±APIå¿…é¡»åŒ…å«æ–‡æ¡£æ³¨é‡Š**
- ä½¿ç”¨ Markdown æ ¼å¼
- åŒ…å«ç¤ºä¾‹ä»£ç 

```rust
/// è®¡ç®—æ–‡ä»¶çš„ SHA-256 å“ˆå¸Œå€¼
///
/// # å‚æ•°
/// - `path`: æ–‡ä»¶è·¯å¾„
///
/// # è¿”å›å€¼
/// - `Ok(String)`: åå…­è¿›åˆ¶æ ¼å¼çš„å“ˆå¸Œå€¼
/// - `Err(io::Error)`: æ–‡ä»¶è¯»å–é”™è¯¯
///
/// # ç¤ºä¾‹
/// ```
/// let hash = calculate_file_hash("/path/to/file.txt")?;
/// println!("File hash: {}", hash);
/// ```
pub fn calculate_file_hash(path: &str) -> Result<String, std::io::Error> {
    // ...
}
```

#### 1.2 æ¨¡å—æ³¨é‡Šï¼ˆ//!ï¼‰
```rust
//! æ–‡ä»¶ç³»ç»Ÿç›‘æ§æ¨¡å—
//!
//! æä¾›å®æ—¶æ–‡ä»¶å˜æ›´æ£€æµ‹åŠŸèƒ½ï¼Œä½¿ç”¨ `notify-rs` åº“å®ç°è·¨å¹³å°ç›‘æ§ã€‚
//! æ”¯æŒåˆ›å»ºã€ä¿®æ”¹ã€åˆ é™¤ã€é‡å‘½åç­‰äº‹ä»¶æ£€æµ‹ã€‚

mod monitor;
mod event_handler;
```

#### 1.3 è¡Œå†…æ³¨é‡Šï¼ˆ//ï¼‰
- **è§£é‡Šå¤æ‚é€»è¾‘**ï¼Œè€Œéæè¿°ä»£ç 
- **é¿å… obvious æ³¨é‡Š**

```rust
// å¢é‡å“ˆå¸Œè®¡ç®—ï¼šæ¯64KBè¯»å–ä¸€æ¬¡ï¼Œé¿å…å†…å­˜å ç”¨è¿‡å¤§
let mut buffer = [0; 65536];

// å¤„ç†è½¯åˆ é™¤ï¼šæ ‡è®°ä¸ºä¸æ´»è·ƒï¼Œä¿ç•™æ ‡ç­¾å…³è”
file.is_active = false;
```

### 2. TypeScript æ³¨é‡Šè§„èŒƒ

#### 2.1 JSDoc æ³¨é‡Š
- **å…¬å…±å‡½æ•°å’Œç»„ä»¶å¿…é¡»åŒ…å« JSDoc**
- ä½¿ç”¨ `@param`, `@returns`, `@example` æ ‡ç­¾

```typescript
/**
 * æ ¹æ®æ–‡ä»¶å¤§å°è¿”å›å¯è¯»çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²
 *
 * @param bytes - æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
 * @returns æ ¼å¼åŒ–åçš„æ–‡ä»¶å¤§å°å­—ç¬¦ä¸²
 *
 * @example
 * ```typescript
 * formatFileSize(1024); // "1 KB"
 * formatFileSize(1048576); // "1 MB"
 * ```
 */
export function formatFileSize(bytes: number): string {
    // ...
}
```

#### 2.2 ç»„ä»¶ Props æ³¨é‡Š
```typescript
interface FileListProps {
    /** è¦æ˜¾ç¤ºçš„æ–‡ä»¶åˆ—è¡¨ */
    files: FileInfo[];
    /** æ–‡ä»¶é€‰æ‹©å›è°ƒå‡½æ•° */
    onSelect?: (file: FileInfo) => void;
    /** æ˜¯å¦æ˜¾ç¤ºåŠ è½½çŠ¶æ€ */
    isLoading?: boolean;
}

/**
 * æ–‡ä»¶åˆ—è¡¨ç»„ä»¶
 *
 * æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨ï¼Œæ”¯æŒé€‰æ‹©ã€æ’åºå’Œæœç´¢åŠŸèƒ½
 */
const FileList: React.FC<FileListProps> = ({
    files,
    onSelect,
    isLoading = false
}) => {
    // ...
};
```

#### 2.3 è¡Œå†…æ³¨é‡Š
```typescript
// é˜²æŠ–å¤„ç†ï¼šé¿å…é¢‘ç¹æœç´¢è¯·æ±‚
const debouncedSearch = useDebounce(searchQuery, 300);

// TODO: æœªæ¥éœ€è¦æ”¯æŒå¤šé€‰åŠŸèƒ½
// FIXME: è¿™é‡Œæœ‰ä¸€ä¸ªå†…å­˜æ³„æ¼é—®é¢˜éœ€è¦ä¿®å¤
```

## ğŸ“ æ–‡ä»¶ç»„ç»‡è§„èŒƒ

### 1. Rust æ¨¡å—ç»„ç»‡

#### 1.1 æ¨¡å—å£°æ˜
```rust
// src/models/mod.rs
pub mod file;
pub mod tag;
pub mod file_tag;

// é‡æ–°å¯¼å‡ºå¸¸ç”¨ç±»å‹
pub use file::File;
pub use tag::Tag;
pub use file_tag::FileTag;
```

#### 1.2 é”™è¯¯å¤„ç†æ¨¡å—
```rust
// src/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("æ–‡ä»¶ä¸å­˜åœ¨: {0}")]
    FileNotFound(String),

    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    DatabaseError(#[from] diesel::result::Error),

    #[error("IOé”™è¯¯: {0}")]
    IoError(#[from] std::io::Error),
}

pub type Result<T> = std::result::Result<T, AppError>;
```

#### 1.3 æœåŠ¡å±‚ç»„ç»‡
```rust
// src/services/mod.rs
pub mod file_service;
pub mod tag_service;
pub mod search_service;
pub mod monitor_service;

// æœåŠ¡ trait å®šä¹‰
pub trait FileService: Send + Sync {
    async fn get_file_info(&self, path: &str) -> Result<FileInfo>;
    async fn add_tag_to_file(&self, path: &str, tag: &str) -> Result<bool>;
}

// å…·ä½“å®ç°
pub struct FileServiceImpl {
    db_pool: DbPool,
    file_cache: Arc<FileCache>,
}
```

### 2. TypeScript/React ç»„ä»¶ç»„ç»‡

#### 2.1 ç»„ä»¶åˆ†ç±»
```
src/components/
â”œâ”€â”€ ui/              # åŸºç¡€UIç»„ä»¶ï¼ˆæŒ‰é’®ã€è¾“å…¥æ¡†ç­‰ï¼‰
â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”œâ”€â”€ Input.tsx
â”‚   â””â”€â”€ Modal.tsx
â”œâ”€â”€ file/            # æ–‡ä»¶ç›¸å…³ç»„ä»¶
â”‚   â”œâ”€â”€ FileList.tsx
â”‚   â”œâ”€â”€ FileItem.tsx
â”‚   â””â”€â”€ FilePreview.tsx
â”œâ”€â”€ tag/             # æ ‡ç­¾ç›¸å…³ç»„ä»¶
â”‚   â”œâ”€â”€ TagPanel.tsx
â”‚   â”œâ”€â”€ TagItem.tsx
â”‚   â””â”€â”€ TagEditor.tsx
â””â”€â”€ layout/          # å¸ƒå±€ç»„ä»¶
    â”œâ”€â”€ Sidebar.tsx
    â”œâ”€â”€ Header.tsx
    â””â”€â”€ MainLayout.tsx
```

#### 2.2 çŠ¶æ€ç®¡ç†ç»„ç»‡
```typescript
// src/stores/fileStore.ts
import { create } from 'zustand';

interface FileStore {
    files: FileInfo[];
    selectedFile: FileInfo | null;
    isLoading: boolean;

    // Actions
    setFiles: (files: FileInfo[]) => void;
    selectFile: (file: FileInfo | null) => void;
    addTagToFile: (filePath: string, tag: string) => Promise<void>;
}

export const useFileStore = create<FileStore>((set, get) => ({
    files: [],
    selectedFile: null,
    isLoading: false,

    setFiles: (files) => set({ files }),
    selectFile: (file) => set({ selectedFile: file }),

    addTagToFile: async (filePath, tag) => {
        set({ isLoading: true });
        try {
            await fileService.addTagToFile(filePath, tag);
            // æ›´æ–°æœ¬åœ°çŠ¶æ€
        } finally {
            set({ isLoading: false });
        }
    },
}));
```

## ğŸ”§ ä»£ç é£æ ¼è§„èŒƒ

### 1. Rust ä»£ç é£æ ¼

#### 1.1 æ ¼å¼åŒ–
- **ä½¿ç”¨ rustfmt**ï¼š`cargo fmt`
- **è¡Œé•¿åº¦**ï¼šä¸è¶…è¿‡ 100 ä¸ªå­—ç¬¦
- **ç¼©è¿›**ï¼š4ä¸ªç©ºæ ¼

#### 1.2 å¯¼å…¥æ’åº
```rust
// æ ‡å‡†åº“
use std::collections::HashMap;
use std::path::Path;

// å¤–éƒ¨åº“
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use tokio::fs;

// å†…éƒ¨æ¨¡å—
use crate::models::File;
use crate::error::Result;
```

#### 1.3 é”™è¯¯å¤„ç†
```rust
// ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
pub async fn process_file(path: &str) -> Result<FileInfo> {
    let metadata = tokio::fs::metadata(path).await?;
    let hash = calculate_file_hash(path).await?;

    Ok(FileInfo {
        path: path.to_string(),
        size: metadata.len(),
        hash,
    })
}

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
fn validate_file_path(path: &str) -> Result<()> {
    if !Path::new(path).exists() {
        return Err(AppError::FileNotFound(path.to_string()));
    }
    Ok(())
}
```

#### 1.4 å¼‚æ­¥ä»£ç 
```rust
// ä½¿ç”¨ async/await
pub async fn scan_directory(path: &str) -> Result<Vec<FileInfo>> {
    let mut entries = tokio::fs::read_dir(path).await?;
    let mut files = Vec::new();

    while let Some(entry) = entries.next_entry().await? {
        let path = entry.path();
        if path.is_file() {
            let file_info = process_file(&path.to_string_lossy()).await?;
            files.push(file_info);
        }
    }

    Ok(files)
}

// ä½¿ç”¨ spawn å¤„ç†å¹¶å‘
pub async fn batch_process_files(paths: &[String]) -> Result<Vec<FileInfo>> {
    let tasks: Vec<_> = paths
        .iter()
        .map(|path| tokio::spawn(process_file(path)))
        .collect();

    let mut results = Vec::new();
    for task in tasks {
        match task.await {
            Ok(Ok(file_info)) => results.push(file_info),
            Ok(Err(e)) => return Err(e),
            Err(e) => return Err(AppError::TaskError(e.to_string())),
        }
    }

    Ok(results)
}
```

### 2. TypeScript ä»£ç é£æ ¼

#### 2.1 æ ¼å¼åŒ–
- **ä½¿ç”¨ Prettier**ï¼šç»Ÿä¸€ä»£ç æ ¼å¼
- **ä½¿ç”¨ ESLint**ï¼šä»£ç è´¨é‡æ£€æŸ¥
- **è¡Œé•¿åº¦**ï¼šä¸è¶…è¿‡ 100 ä¸ªå­—ç¬¦

#### 2.2 ç±»å‹å®šä¹‰
```typescript
// æ˜ç¡®ç±»å‹ï¼Œé¿å…ä½¿ç”¨ any
const fileList: FileInfo[] = [];

// ä½¿ç”¨ç±»å‹åˆ«åæé«˜å¯è¯»æ€§
type FilePath = string;
type TagName = string;

// ä½¿ç”¨è”åˆç±»å‹
type SearchOperator = 'AND' | 'OR' | 'NOT';

// ä½¿ç”¨å¯é€‰å±æ€§å’Œé»˜è®¤å€¼
interface SearchOptions {
    tags?: string[];
    operator?: SearchOperator;
    limit?: number;
}

const defaultOptions: SearchOptions = {
    tags: [],
    operator: 'AND',
    limit: 100,
};
```

#### 2.3 React ç»„ä»¶è§„èŒƒ
```typescript
// ä½¿ç”¨å‡½æ•°ç»„ä»¶å’Œ Hooks
const FileList: React.FC<FileListProps> = ({ files, onSelect }) => {
    const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
    const fileStore = useFileStore();

    // ä½¿ç”¨ useCallback ä¼˜åŒ–æ€§èƒ½
    const handleSelect = useCallback((index: number) => {
        setSelectedIndex(index);
        if (onSelect) {
            onSelect(files[index]);
        }
    }, [files, onSelect]);

    // ä½¿ç”¨ useMemo é¿å…é‡å¤è®¡ç®—
    const filteredFiles = useMemo(() => {
        return files.filter(file => file.size > 0);
    }, [files]);

    return (
        <div className="file-list">
            {filteredFiles.map((file, index) => (
                <FileItem
                    key={file.path}
                    file={file}
                    isSelected={index === selectedIndex}
                    onSelect={() => handleSelect(index)}
                />
            ))}
        </div>
    );
};

// å¯¼å‡ºç»„ä»¶
export default FileList;
```

#### 2.4 å¼‚æ­¥å¤„ç†
```typescript
// ä½¿ç”¨ async/await
async function loadFiles(directory: string): Promise<FileInfo[]> {
    try {
        const response = await invoke<FileInfo[]>('scan_directory', { path: directory });
        return response;
    } catch (error) {
        console.error('Failed to load files:', error);
        throw new Error(`æ— æ³•åŠ è½½ç›®å½•: ${directory}`);
    }
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
const FileBrowser: React.FC = () => {
    const [files, setFiles] = useState<FileInfo[]>([]);
    const [isLoading, setIsLoading] = useState(false);

    const loadDirectory = useCallback(async (directory: string) => {
        setIsLoading(true);
        try {
            const loadedFiles = await loadFiles(directory);
            setFiles(loadedFiles);
        } catch (error) {
            // é”™è¯¯å¤„ç†
        } finally {
            setIsLoading(false);
        }
    }, []);

    // ...
};
```

## ğŸ§ª æµ‹è¯•è§„èŒƒ

### 1. Rust æµ‹è¯•è§„èŒƒ

#### 1.1 å•å…ƒæµ‹è¯•
```rust
// ä¸è¢«æµ‹è¯•ä»£ç æ”¾åœ¨åŒä¸€æ–‡ä»¶
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_file_hash() {
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        let test_data = b"test content";
        let temp_file = tempfile::NamedTempFile::new().unwrap();
        std::fs::write(temp_file.path(), test_data).unwrap();

        // æ‰§è¡Œæµ‹è¯•
        let result = calculate_file_hash(temp_file.path().to_str().unwrap());

        // éªŒè¯ç»“æœ
        assert!(result.is_ok());
        let hash = result.unwrap();
        assert_eq!(hash.len(), 64); // SHA-256 å“ˆå¸Œé•¿åº¦
    }

    #[tokio::test]
    async fn test_async_file_processing() {
        // å¼‚æ­¥æµ‹è¯•
        let result = process_file("test.txt").await;
        assert!(result.is_ok());
    }
}
```

#### 1.2 é›†æˆæµ‹è¯•
```rust
// tests/integration_tests.rs
#[cfg(test)]
mod integration_tests {
    use file_manager::services::FileService;
    use file_manager::database::TestDatabase;

    #[tokio::test]
    async fn test_file_service_integration() {
        // è®¾ç½®æµ‹è¯•æ•°æ®åº“
        let db = TestDatabase::new().await;
        let service = FileServiceImpl::new(db.pool());

        // æµ‹è¯•å®Œæ•´æµç¨‹
        let result = service.add_tag_to_file("test.txt", "important").await;
        assert!(result.is_ok());
    }
}
```

### 2. TypeScript æµ‹è¯•è§„èŒƒ

#### 2.1 ç»„ä»¶æµ‹è¯•
```typescript
// FileList.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import FileList from './FileList';

const mockFiles: FileInfo[] = [
    { path: '/test/file1.txt', size: 1024, type: 'txt' },
    { path: '/test/file2.jpg', size: 2048, type: 'jpg' },
];

describe('FileList', () => {
    it('æ¸²æŸ“æ–‡ä»¶åˆ—è¡¨', () => {
        render(<FileList files={mockFiles} />);

        expect(screen.getByText('file1.txt')).toBeInTheDocument();
        expect(screen.getByText('file2.jpg')).toBeInTheDocument();
    });

    it('å¤„ç†æ–‡ä»¶é€‰æ‹©', () => {
        const handleSelect = jest.fn();
        render(<FileList files={mockFiles} onSelect={handleSelect} />);

        fireEvent.click(screen.getByText('file1.txt'));
        expect(handleSelect).toHaveBeenCalledWith(mockFiles[0]);
    });
});
```

#### 2.2 å·¥å…·å‡½æ•°æµ‹è¯•
```typescript
// formatters.test.ts
import { formatFileSize } from './formatters';

describe('formatFileSize', () => {
    it('æ ¼å¼åŒ–å­—èŠ‚', () => {
        expect(formatFileSize(0)).toBe('0 B');
        expect(formatFileSize(1023)).toBe('1023 B');
    });

    it('æ ¼å¼åŒ–åƒå­—èŠ‚', () => {
        expect(formatFileSize(1024)).toBe('1 KB');
        expect(formatFileSize(2048)).toBe('2 KB');
    });

    it('æ ¼å¼åŒ–å…†å­—èŠ‚', () => {
        expect(formatFileSize(1048576)).toBe('1 MB');
    });
});
```

## ğŸ” ä»£ç å®¡æŸ¥è¦ç‚¹

### 1. Rust ä»£ç å®¡æŸ¥
- [ ] **æ‰€æœ‰æƒå’Œå€Ÿç”¨**ï¼šæ£€æŸ¥æ˜¯å¦æ­£ç¡®ä½¿ç”¨æ‰€æœ‰æƒç³»ç»Ÿ
- [ ] **é”™è¯¯å¤„ç†**ï¼šæ˜¯å¦å¦¥å–„å¤„ç†æ‰€æœ‰å¯èƒ½çš„é”™è¯¯
- [ ] **å¼‚æ­¥å®‰å…¨**ï¼šæ£€æŸ¥ `Send` å’Œ `Sync` çº¦æŸ
- [ ] **å†…å­˜å®‰å…¨**ï¼šé¿å…å†…å­˜æ³„æ¼å’Œæ‚¬å‚æŒ‡é’ˆ
- [ ] **æ€§èƒ½è€ƒè™‘**ï¼šé¿å…ä¸å¿…è¦çš„å…‹éš†å’Œåˆ†é…

### 2. TypeScript ä»£ç å®¡æŸ¥
- [ ] **ç±»å‹å®‰å…¨**ï¼šé¿å…ä½¿ç”¨ `any` ç±»å‹
- [ ] **React æœ€ä½³å®è·µ**ï¼šæ­£ç¡®ä½¿ç”¨ Hooks
- [ ] **æ€§èƒ½ä¼˜åŒ–**ï¼šé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
- [ ] **é”™è¯¯å¤„ç†**ï¼šå¦¥å–„å¤„ç†å¼‚æ­¥é”™è¯¯
- [ ] **å¯è®¿é—®æ€§**ï¼šè€ƒè™‘æ— éšœç¢è®¿é—®

## ğŸ› ï¸ å·¥å…·é…ç½®

### 1. Rust å·¥å…·é…ç½®
```toml
# .cargo/config.toml
[build]
rustflags = ["-D", "warnings"]

[rust]
rustfmt = true
clippy = true
```

### 2. TypeScript å·¥å…·é…ç½®
```json
// .eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "react/prop-types": "off"
  }
}
```

```json
// .prettierrc.json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}
```

## ğŸ“š æ–‡æ¡£è§„èŒƒ

### 1. API æ–‡æ¡£
- **æ‰€æœ‰å…¬å…±APIå¿…é¡»åŒ…å«æ–‡æ¡£æ³¨é‡Š**
- **åŒ…å«ç¤ºä¾‹ä»£ç **
- **è¯´æ˜é”™è¯¯æƒ…å†µ**

### 2. README æ–‡ä»¶
- **é¡¹ç›®æ¦‚è¿°**ï¼šç®€è¦è¯´æ˜é¡¹ç›®ç›®çš„
- **å¿«é€Ÿå¼€å§‹**ï¼šå®‰è£…å’Œè¿è¡ŒæŒ‡å—
- **æ¶æ„è¯´æ˜**ï¼šæŠ€æœ¯æ ˆå’Œè®¾è®¡
- **å¼€å‘æŒ‡å—**ï¼šå¦‚ä½•è´¡çŒ®ä»£ç 

### 3. CHANGELOG æ–‡ä»¶
- **éµå¾ªè¯­ä¹‰åŒ–ç‰ˆæœ¬**ï¼šMAJOR.MINOR.PATCH
- **æŒ‰ç‰ˆæœ¬åˆ†ç»„**ï¼šè®°å½•æ‰€æœ‰å˜æ›´
- **åŒ…å«è¿ç§»æŒ‡å—**ï¼šé‡å¤§å˜æ›´è¯´æ˜

## ğŸš€ æäº¤è§„èŒƒ

### 1. Git æäº¤æ¶ˆæ¯
```
<ç±»å‹>: <ç®€çŸ­æè¿°>

<è¯¦ç»†æè¿°>

<ç›¸å…³issue>
```

**ç±»å‹**ï¼š
- `feat`: æ–°åŠŸèƒ½
- `fix`: ä¿®å¤bug
- `docs`: æ–‡æ¡£æ›´æ–°
- `style`: ä»£ç æ ¼å¼è°ƒæ•´
- `refactor`: ä»£ç é‡æ„
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·

**ç¤ºä¾‹**ï¼š
```
feat: æ·»åŠ æ–‡ä»¶æ ‡ç­¾ç®¡ç†åŠŸèƒ½

- å®ç°æ ‡ç­¾æ·»åŠ ã€åˆ é™¤ã€æœç´¢åŠŸèƒ½
- æ·»åŠ æ ‡ç­¾é¢œè‰²æ”¯æŒ
- æ›´æ–°æ•°æ®åº“è¿ç§»è„šæœ¬

Closes #123
```

### 2. åˆ†æ”¯å‘½å
- `feature/`ï¼šæ–°åŠŸèƒ½å¼€å‘
- `bugfix/`ï¼šbugä¿®å¤
- `hotfix/`ï¼šç´§æ€¥ä¿®å¤
- `release/`ï¼šå‘å¸ƒåˆ†æ”¯

**ç¤ºä¾‹**ï¼š
```
feature/file-tag-management
bugfix/fix-memory-leak
hotfix/critical-security-fix
```

## ğŸ“Š ä»£ç è´¨é‡æŒ‡æ ‡

### 1. Rust è´¨é‡æŒ‡æ ‡
- **æµ‹è¯•è¦†ç›–ç‡**ï¼š> 80%
- **Clippy è­¦å‘Š**ï¼š0 è­¦å‘Š
- **ç¼–è¯‘æ—¶é—´**ï¼šä¼˜åŒ–å¢é‡ç¼–è¯‘
- **äºŒè¿›åˆ¶å¤§å°**ï¼šæ§åˆ¶æœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶å¤§å°

### 2. TypeScript è´¨é‡æŒ‡æ ‡
- **æµ‹è¯•è¦†ç›–ç‡**ï¼š> 80%
- **ESLint é”™è¯¯**ï¼š0 é”™è¯¯
- **ç±»å‹è¦†ç›–ç‡**ï¼š100%
- **åŒ…å¤§å°**ï¼šæ§åˆ¶ bundle å¤§å°

---

*æŠ€æœ¯è§„èŒƒç‰ˆæœ¬ï¼šv1.0*
*åˆ¶å®šæ—¥æœŸï¼š2025-12-05*
*é€‚ç”¨é¡¹ç›®ï¼šæ–‡ä»¶ç®¡ç†ç³»ç»Ÿï¼ˆRust + Tauri + TypeScriptï¼‰*