# Windows本地文件管理系统 - 技术栈方案

## 1. 开发语言选择

### 1.1 主要候选方案

#### 方案A：Rust + Tauri + PostgreSQL (推荐)
**优势：**
- Rust提供内存安全和极致性能
- Tauri提供轻量级Web前端 + Rust后端
- PostgreSQL强大的数据管理能力
- 跨平台潜力（Windows/macOS/Linux）
- 现代技术栈，学习价值高

**技术栈：**
- **后端语言**：Rust 1.70+
- **前端框架**：Tauri 2.0 + 任意前端框架（React/Vue/Svelte）
- **数据库**：PostgreSQL 15+（或SQLite for 轻量版）
- **ORM**：Diesel 或 SeaORM
- **Web框架**：Axum 或 Actix-web（如需REST API）
- **文件监控**：notify-rs（跨平台文件系统监控）
- **哈希计算**：rust-crypto 或 ring
- **打包**：Tauri CLI

#### 方案B：C# + .NET Framework/.NET Core
**优势：**
- 原生Windows支持，系统API调用方便
- 强大的文件系统操作库
- WPF/WinForms成熟的UI框架
- Visual Studio优秀的开发体验
- 良好的性能和内存管理

**技术栈：**
- **语言**：C# 10+
- **框架**：.NET 6/7/8 (跨平台) 或 .NET Framework 4.8 (纯Windows)
- **UI框架**：WPF (现代化) 或 WinForms (快速开发)
- **数据库**：SQLite + Entity Framework Core
- **依赖注入**：Microsoft.Extensions.DependencyInjection
- **日志**：Serilog 或 NLog
- **测试**：xUnit + Moq

#### 方案C：Electron + Node.js
**优势：**
- Web技术栈，前端开发者友好
- 跨平台能力最强
- 丰富的UI组件库
- 热更新方便

**劣势：**
- 资源占用较高
- 文件系统操作需要Native模块
- Windows系统集成较弱

## 2. 推荐技术栈：Rust + Tauri + PostgreSQL

### 2.1 核心框架选择
```
┌─────────────────────────────────────┐
│         应用程序层                   │
│  Tauri + React/Vue + TypeScript     │
├─────────────────────────────────────┤
│         业务逻辑层                   │
│  Rust服务 + 领域模型 + 事件驱动      │
├─────────────────────────────────────┤
│         数据访问层                   │
│  PostgreSQL + Diesel/SeaORM         │
├─────────────────────────────────────┤
│         系统接口层                   │
│  Rust系统调用 + 文件系统监控         │
└─────────────────────────────────────┘
```

### 2.2 详细技术组件

#### 2.2.1 前端/UI层
- **UI框架**：Tauri 2.0（WebView + Rust后端）
- **前端框架**（三选一）：
  - **React 18** + TypeScript + Vite（推荐，生态丰富）
  - **Vue 3** + TypeScript + Vite（简洁易用）
  - **Svelte 4** + TypeScript + Vite（高性能）
- **UI组件库**：
  - **React**：Ant Design、MUI、Shadcn/ui
  - **Vue**：Element Plus、Naive UI、PrimeVue
  - **Svelte**：SvelteKit、Svelte Material UI
- **状态管理**：
  - React：Zustand、Redux Toolkit
  - Vue：Pinia
  - Svelte：内置store
- **CSS框架**：Tailwind CSS + DaisyUI

#### 2.2.2 Rust后端层
- **Web框架**：Axum（轻量级异步）或 Actix-web（功能全面）
- **依赖注入**：Shuttle（云原生）或 手动依赖管理
- **配置管理**：Figment + serde
- **日志系统**：tracing + tracing-subscriber
  - 结构化日志
  - 文件日志输出
  - 性能追踪
- **异步运行时**：tokio（高性能异步）
- **序列化**：serde + serde_json
- **验证**：validator

#### 2.2.3 数据访问层
- **数据库**：PostgreSQL 15+
  - 强大的关系型数据库
  - JSONB支持（存储灵活数据）
  - 全文搜索（pg_trgm扩展）
  - 高级索引（GIN、GiST）
- **ORM选择**：
  - **Diesel**：类型安全，编译时查询检查
  - **SeaORM**：异步支持，更现代的API
  - **sqlx**：纯SQL，零开销
- **连接池**：deadpool-postgres 或 bb8
- **迁移工具**：diesel-cli 或 sea-orm-cli
- **缓存**：Redis（可选）或 内存缓存

#### 2.2.4 系统接口层
- **文件系统操作**：
  - `std::fs` + `tokio::fs`（异步文件操作）
  - `walkdir`（目录遍历）
  - `path-absolutize`（路径处理）
- **文件监控**：`notify-rs`
  - 跨平台文件系统监控
  - 防抖和批量处理
  - 自定义事件过滤
- **系统集成**：
  - `windows-rs` 或 `winapi`（Windows API）
  - 系统托盘：`tao` + `wry`
  - 注册表操作：`winreg`
- **安全**：
  - 哈希计算：`ring`（SHA-256, SHA-512）
  - 加密：`aes-gcm`、`chacha20poly1305`
  - 密码学：`rust-crypto`

#### 2.2.5 工具和库
- **命令行解析**：clap
- **配置文件**：toml、yaml、json支持
- **日期时间**：chrono
- **随机数**：rand
- **压缩解压**：flate2、zip
- **CSV处理**：csv
- **HTTP客户端**：reqwest
- **WebSocket**：tokio-tungstenite
- **测试框架**：cargo test + criterion（基准测试）

## 3. 开发环境配置

### 3.1 必需工具
- **Rust工具链**：
  - Rustup（Rust版本管理）
  - Rust 1.70+ stable
  - Cargo（包管理器）
- **前端工具**：
  - Node.js 18+ 和 npm/yarn/pnpm
  - 选择的前端框架（React/Vue/Svelte）
  - Vite（构建工具）
- **数据库**：
  - PostgreSQL 15+（推荐使用Docker）
  - pgAdmin 或 DBeaver（数据库管理）
  - PostgreSQL扩展：pg_trgm（模糊搜索）
- **Tauri CLI**：
  - `cargo install tauri-cli`
  - 用于创建、构建、开发Tauri应用
- **版本控制**：Git + GitHub Desktop
- **代码编辑器**：
  - **VS Code**（推荐）：Rust Analyzer扩展
  - **IntelliJ IDEA**：Rust插件
  - **Neovim**：coc-rust-analyzer

### 3.2 推荐扩展和工具
- **VS Code扩展**：
  - Rust Analyzer（Rust语言支持）
  - Tauri（Tauri开发支持）
  - ES7+ React/Redux/React-Native snippets
  - Tailwind CSS IntelliSense
  - PostgreSQL（数据库管理）
- **数据库工具**：
  - DBeaver（通用数据库管理）
  - pgAdmin（PostgreSQL专用）
  - TablePlus（现代数据库客户端）
- **其他工具**：
  - Docker Desktop（运行PostgreSQL）
  - WSL2（Windows Subsystem for Linux，可选）
  - Postman/Insomnia（API测试）
  - Process Explorer（进程监控）

## 4. 项目结构设计

### 4.1 项目结构（Tauri标准结构）
```
file-manager/
├── src-tauri/                    # Rust后端代码
│   ├── src/
│   │   ├── main.rs              # 应用入口
│   │   ├── commands.rs          # Tauri命令定义
│   │   ├── models/              # 数据模型
│   │   │   ├── mod.rs
│   │   │   ├── file.rs          # 文件模型
│   │   │   ├── tag.rs           # 标签模型
│   │   │   └── file_tag.rs      # 文件-标签关联
│   │   ├── services/            # 业务服务
│   │   │   ├── mod.rs
│   │   │   ├── file_service.rs  # 文件服务
│   │   │   ├── tag_service.rs   # 标签服务
│   │   │   ├── search_service.rs # 搜索服务
│   │   │   └── monitor_service.rs # 监控服务
│   │   ├── database/            # 数据库层
│   │   │   ├── mod.rs
│   │   │   ├── connection.rs    # 数据库连接
│   │   │   ├── migrations/      # 数据库迁移
│   │   │   └── repository.rs    # 数据访问
│   │   ├── system/              # 系统接口
│   │   │   ├── mod.rs
│   │   │   ├── file_system.rs   # 文件系统操作
│   │   │   ├── monitor.rs       # 文件监控
│   │   │   └── windows_api.rs   # Windows API调用
│   │   └── utils/               # 工具函数
│   │       ├── mod.rs
│   │       ├── hash.rs          # 哈希计算
│   │       ├── path.rs          # 路径处理
│   │       └── error.rs         # 错误处理
│   ├── Cargo.toml               # Rust依赖配置
│   ├── tauri.conf.json          # Tauri应用配置
│   └── build.rs                 # 构建脚本
├── src/                         # 前端代码（React示例）
│   ├── main.tsx                 # 应用入口
│   ├── App.tsx                  # 主组件
│   ├── components/              # 可复用组件
│   │   ├── FileList.tsx         # 文件列表
│   │   ├── TagPanel.tsx         # 标签面板
│   │   ├── SearchBar.tsx        # 搜索栏
│   │   └── FilePreview.tsx      # 文件预览
│   ├── pages/                   # 页面组件
│   │   ├── HomePage.tsx         # 主页
│   │   ├── SearchPage.tsx       # 搜索页
│   │   └── SettingsPage.tsx     # 设置页
│   ├── stores/                  # 状态管理
│   │   ├── fileStore.ts         # 文件状态
│   │   ├── tagStore.ts          # 标签状态
│   │   └── uiStore.ts           # UI状态
│   ├── services/                # 前端服务
│   │   ├── api.ts               # API调用封装
│   │   ├── fileService.ts       # 文件操作服务
│   │   └── tagService.ts        # 标签操作服务
│   ├── types/                   # TypeScript类型定义
│   │   ├── file.ts              # 文件类型
│   │   ├── tag.ts               # 标签类型
│   │   └── api.ts               # API响应类型
│   ├── styles/                  # 样式文件
│   │   ├── globals.css          # 全局样式
│   │   └── components.css       # 组件样式
│   └── utils/                   # 工具函数
│       ├── formatters.ts        # 格式化函数
│       └── validators.ts        # 验证函数
├── public/                      # 静态资源
│   ├── icons/                   # 图标文件
│   └── images/                  # 图片资源
├── migrations/                  # 数据库迁移文件（Diesel）
│   ├── 00000000000000_diesel_initial_setup/
│   └── 20231205000000_create_files_table/
├── tests/                       # 测试文件
│   ├── unit/                    # 单元测试
│   ├── integration/             # 集成测试
│   └── e2e/                     # 端到端测试
├── .cargo/                      # Cargo配置
├── .vscode/                     # VS Code配置
├── package.json                 # 前端依赖
├── tsconfig.json                # TypeScript配置
├── vite.config.ts               # Vite配置
├── tailwind.config.js           # Tailwind配置
├── postcss.config.js            # PostCSS配置
└── README.md                    # 项目说明
```

### 4.2 关键类设计

### 4.2 关键接口设计

#### 4.2.1 Rust后端服务接口
```rust
// 文件指纹服务
pub trait FileFingerprintService {
    async fn generate_file_hash(&self, file_path: &str) -> Result<String>;
    async fn generate_fingerprint(&self, file_path: &str) -> Result<FileFingerprint>;
    async fn verify_file_identity(&self, file_path: &str, expected_hash: &str) -> Result<bool>;
}

// 标签管理服务
pub trait TagService {
    async fn create_tag(&self, name: &str, color: Option<&str>) -> Result<Tag>;
    async fn add_tag_to_file(&self, file_path: &str, tag_name: &str) -> Result<bool>;
    async fn remove_tag_from_file(&self, file_path: &str, tag_name: &str) -> Result<bool>;
    async fn search_files_by_tags(
        &self,
        tags: &[String],
        operator: SearchOperator,
    ) -> Result<Vec<FileInfo>>;
}

// 文件监控服务
pub trait FileMonitorService {
    fn start_monitoring(&self, path: &str) -> Result<()>;
    fn stop_monitoring(&self) -> Result<()>;
    fn subscribe(&self) -> tokio::sync::broadcast::Receiver<FileChangeEvent>;
}

// 搜索服务
pub trait SearchService {
    async fn search(&self, query: SearchQuery) -> Result<SearchResult>;
    async fn suggest_tags(&self, partial_tag: &str) -> Result<Vec<String>>;
    async fn suggest_files(&self, partial_file_name: &str) -> Result<Vec<String>>;
}

// Tauri命令接口（前端调用）
#[tauri::command]
async fn add_tag_to_file(
    file_path: String,
    tag_name: String,
    tag_service: State<'_, TagServiceImpl>,
) -> Result<bool, String> {
    tag_service.add_tag_to_file(&file_path, &tag_name).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
async fn search_files(
    query: SearchQuery,
    search_service: State<'_, SearchServiceImpl>,
) -> Result<SearchResult, String> {
    search_service.search(query).await
        .map_err(|e| e.to_string())
}
```

#### 4.2.2 前端TypeScript接口
```typescript
// API服务接口
interface FileService {
  getFileInfo(path: string): Promise<FileInfo>;
  addTagToFile(path: string, tag: string): Promise<boolean>;
  removeTagFromFile(path: string, tag: string): Promise<boolean>;
  scanDirectory(path: string): Promise<ScanResult>;
}

interface TagService {
  createTag(name: string, color?: string): Promise<Tag>;
  getTags(): Promise<Tag[]>;
  deleteTag(name: string): Promise<boolean>;
  updateTag(tag: Tag): Promise<Tag>;
}

interface SearchService {
  search(query: SearchQuery): Promise<SearchResult>;
  suggestTags(query: string): Promise<string[]>;
  suggestFiles(query: string): Promise<string[]>;
}

// Tauri命令调用封装
class TauriFileService implements FileService {
  async addTagToFile(path: string, tag: string): Promise<boolean> {
    return await invoke<boolean>('add_tag_to_file', { filePath: path, tagName: tag });
  }

  async searchFiles(query: SearchQuery): Promise<SearchResult> {
    return await invoke<SearchResult>('search_files', { query });
  }
}
```

## 5. PostgreSQL数据库设计

### 5.1 数据库表设计（Diesel Schema）
```rust
// schema.rs - Diesel数据库模式定义
table! {
    files (id) {
        id -> Int4,
        file_hash -> Varchar,          // SHA-256哈希
        path_hash -> Varchar,          // 路径哈希
        original_path -> Nullable<Text>,
        current_path -> Text,
        file_name -> Varchar,
        file_size -> Int8,
        file_type -> Varchar,
        created_time -> Timestamp,
        modified_time -> Timestamp,
        last_seen_time -> Timestamp,
        fingerprint_data -> Bytea,      // 二进制指纹数据
        is_active -> Bool,
    }
}

table! {
    tags (id) {
        id -> Int4,
        name -> Varchar,
        color -> Nullable<Varchar>,
        icon -> Nullable<Varchar>,
        parent_id -> Nullable<Int4>,
        description -> Nullable<Text>,
        created_time -> Timestamp,
        usage_count -> Int4,
    }
}

table! {
    file_tags (file_id, tag_id) {
        file_id -> Int4,
        tag_id -> Int4,
        added_time -> Timestamp,
        added_by -> Nullable<Varchar>,
        confidence -> Float4,
    }
}

table! {
    file_changes (id) {
        id -> Int4,
        file_id -> Int4,
        change_type -> Varchar,        // MOVE, RENAME, MODIFY, DELETE
        old_path -> Nullable<Text>,
        new_path -> Nullable<Text>,
        old_hash -> Nullable<Varchar>,
        new_hash -> Nullable<Varchar>,
        change_time -> Timestamp,
        detected_time -> Timestamp,
    }
}

// 表关联
joinable!(file_tags -> files (file_id));
joinable!(file_tags -> tags (tag_id));
joinable!(file_changes -> files (file_id));
allow_tables_to_appear_in_same_query!(files, tags, file_tags, file_changes);
```

### 5.2 PostgreSQL性能优化
```sql
-- 索引优化
CREATE INDEX idx_files_hash ON files USING hash(file_hash);
CREATE INDEX idx_files_path_hash ON files USING hash(path_hash);
CREATE INDEX idx_files_current_path ON files USING gin(current_path gin_trgm_ops);
CREATE INDEX idx_files_is_active ON files(is_active) WHERE is_active = true;

CREATE INDEX idx_tags_name ON tags USING gin(name gin_trgm_ops);
CREATE INDEX idx_tags_parent_id ON tags(parent_id);

CREATE INDEX idx_file_tags_composite ON file_tags(file_id, tag_id);
CREATE INDEX idx_file_tags_tag_id ON file_tags(tag_id);

-- 全文搜索优化
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS btree_gin;

-- 物化视图（提高复杂查询性能）
CREATE MATERIALIZED VIEW mv_file_tags_summary AS
SELECT
    f.id as file_id,
    f.current_path,
    f.file_name,
    f.file_type,
    array_agg(t.name) as tags,
    array_agg(t.color) as tag_colors
FROM files f
LEFT JOIN file_tags ft ON f.id = ft.file_id
LEFT JOIN tags t ON ft.tag_id = t.id
WHERE f.is_active = true
GROUP BY f.id, f.current_path, f.file_name, f.file_type;

CREATE UNIQUE INDEX idx_mv_file_tags_summary ON mv_file_tags_summary(file_id);
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_file_tags_summary;

-- 函数索引（标签搜索优化）
CREATE INDEX idx_tags_search ON tags USING gin(to_tsvector('english', name));

-- 分区表（可选，针对超大数据量）
CREATE TABLE files_partitioned (LIKE files INCLUDING ALL) PARTITION BY HASH(id);
CREATE TABLE files_partition_0 PARTITION OF files_partitioned FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE files_partition_1 PARTITION OF files_partitioned FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE files_partition_2 PARTITION OF files_partitioned FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE files_partition_3 PARTITION OF files_partitioned FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

### 5.3 Rust数据库连接管理
```rust
// database/connection.rs
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool, PooledConnection};
use std::env;

pub type DbPool = Pool<ConnectionManager<PgConnection>>;
pub type DbConnection = PooledConnection<ConnectionManager<PgConnection>>;

pub fn create_connection_pool() -> DbPool {
    let database_url = env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://postgres:password@localhost/filemanager".to_string());

    let manager = ConnectionManager::<PgConnection>::new(database_url);

    Pool::builder()
        .max_size(20) // 连接池大小
        .min_idle(Some(5)) // 最小空闲连接
        .connection_timeout(std::time::Duration::from_secs(30))
        .test_on_check_out(true)
        .build(manager)
        .expect("Failed to create database connection pool")
}

// 数据库配置优化
pub fn optimize_database_connection(conn: &mut PgConnection) -> Result<(), diesel::result::Error> {
    // 设置连接参数
    diesel::sql_query("SET statement_timeout = 30000").execute(conn)?; // 30秒超时
    diesel::sql_query("SET idle_in_transaction_session_timeout = 10000").execute(conn)?; // 10秒空闲超时
    diesel::sql_query("SET lock_timeout = 5000").execute(conn)?; // 5秒锁超时

    // 设置搜索路径
    diesel::sql_query("SET search_path TO public").execute(conn)?;

    Ok(())
}

// 连接池健康检查
pub async fn check_pool_health(pool: &DbPool) -> bool {
    match pool.get() {
        Ok(mut conn) => {
            // 执行简单查询检查连接
            diesel::sql_query("SELECT 1").execute(&mut conn).is_ok()
        }
        Err(_) => false,
    }
}
```

## 6. 文件系统监控方案（Rust实现）

### 6.1 监控策略（使用notify-rs）
```rust
// system/monitor.rs
use notify::{RecommendedWatcher, RecursiveMode, Watcher, Event, EventKind};
use std::path::Path;
use std::sync::Arc;
use tokio::sync::{mpsc, broadcast};
use tokio::time::{interval, Duration};
use dashmap::DashMap;

pub struct HybridFileMonitor {
    real_time_watcher: RecommendedWatcher,
    periodic_scanner: tokio::time::Interval,
    change_queue: mpsc::UnboundedSender<FileChangeEvent>,
    file_cache: Arc<DashMap<String, FileCacheEntry>>,
}

pub struct FileChangeEvent {
    pub path: String,
    pub kind: FileChangeKind,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub enum FileChangeKind {
    Created,
    Modified,
    Deleted,
    Renamed { old_path: String },
}

impl HybridFileMonitor {
    pub fn new(
        watch_path: &str,
        change_tx: mpsc::UnboundedSender<FileChangeEvent>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        // 创建实时监控器
        let (real_time_tx, mut real_time_rx) = mpsc::unbounded_channel();
        let mut real_time_watcher = RecommendedWatcher::new(
            move |res: Result<Event, notify::Error>| {
                if let Ok(event) = res {
                    let _ = real_time_tx.send(event);
                }
            },
            notify::Config::default(),
        )?;

        // 开始监控
        real_time_watcher.watch(Path::new(watch_path), RecursiveMode::Recursive)?;

        // 创建定时扫描器（每5分钟）
        let periodic_scanner = interval(Duration::from_secs(300));

        // 文件缓存（用于变更检测）
        let file_cache = Arc::new(DashMap::new());

        let monitor = Self {
            real_time_watcher,
            periodic_scanner,
            change_queue: change_tx,
            file_cache,
        };

        // 启动实时监控处理任务
        tokio::spawn(Self::process_real_time_events(
            real_time_rx,
            change_tx.clone(),
            monitor.file_cache.clone(),
        ));

        Ok(monitor)
    }

    async fn process_real_time_events(
        mut rx: mpsc::UnboundedReceiver<Event>,
        tx: mpsc::UnboundedSender<FileChangeEvent>,
        cache: Arc<DashMap<String, FileCacheEntry>>,
    ) {
        while let Some(event) = rx.recv().await {
            for path in event.paths {
                let path_str = path.to_string_lossy().to_string();

                match event.kind {
                    EventKind::Create(_) => {
                        let change_event = FileChangeEvent {
                            path: path_str,
                            kind: FileChangeKind::Created,
                            timestamp: chrono::Utc::now(),
                        };
                        let _ = tx.send(change_event);
                    }
                    EventKind::Modify(_) => {
                        let change_event = FileChangeEvent {
                            path: path_str,
                            kind: FileChangeKind::Modified,
                            timestamp: chrono::Utc::now(),
                        };
                        let _ = tx.send(change_event);
                    }
                    EventKind::Remove(_) => {
                        let change_event = FileChangeEvent {
                            path: path_str,
                            kind: FileChangeKind::Deleted,
                            timestamp: chrono::Utc::now(),
                        };
                        let _ = tx.send(change_event);
                    }
                    EventKind::Rename(rename_event) => {
                        if let Some(old_path) = rename_event.from {
                            let change_event = FileChangeEvent {
                                path: path_str,
                                kind: FileChangeKind::Renamed {
                                    old_path: old_path.to_string_lossy().to_string(),
                                },
                                timestamp: chrono::Utc::now(),
                            };
                            let _ = tx.send(change_event);
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    // 文件变更识别算法
    fn identify_change_type(
        old_path: &str,
        new_path: &str,
        old_hash: &str,
        new_hash: &str,
    ) -> FileChangeType {
        if old_path != new_path && old_hash == new_hash {
            FileChangeType::Moved
        } else if old_path == new_path && old_hash != new_hash {
            FileChangeType::Modified
        } else if old_path != new_path && old_hash != new_hash {
            FileChangeType::MovedAndModified
        } else {
            FileChangeType::Unknown
        }
    }

    // 启动定时扫描
    pub async fn start_periodic_scan(&mut self) {
        let tx = self.change_queue.clone();
        let cache = self.file_cache.clone();

        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(300)).await;

                // 执行全量扫描
                if let Err(e) = Self::perform_full_scan(&tx, &cache).await {
                    eprintln!("Periodic scan error: {}", e);
                }
            }
        });
    }

    async fn perform_full_scan(
        tx: &mpsc::UnboundedSender<FileChangeEvent>,
        cache: &Arc<DashMap<String, FileCacheEntry>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // 实现全量文件扫描逻辑
        // 比较当前文件状态与缓存状态
        // 发送变更事件
        Ok(())
    }
}

#[derive(Debug)]
pub enum FileChangeType {
    Moved,
    Modified,
    MovedAndModified,
    Unknown,
}

struct FileCacheEntry {
    hash: String,
    size: u64,
    modified: std::time::SystemTime,
}
```

## 7. 部署和分发（Tauri应用）

### 7.1 Tauri打包方案
Tauri提供了完整的跨平台打包解决方案：

#### 7.1.1 构建配置
```javascript
// tauri.conf.json 配置示例
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:1420",
    "distDir": "../dist"
  },
  "package": {
    "productName": "File Manager",
    "version": "1.0.0"
  },
  "tauri": {
    "bundle": {
      "active": true,
      "targets": "all", // 或指定 "msi", "app", "dmg", "deb"
      "identifier": "com.filemanager.app",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "resources": [],
      "externalBin": [],
      "copyright": "© 2025 File Manager Team",
      "category": "Utility",
      "shortDescription": "A tag-based file management system",
      "longDescription": "Manage your files with tags, search efficiently, and track file changes.",
      "deb": {
        "depends": []
      },
      "macOS": {
        "frameworks": [],
        "minimumSystemVersion": "10.13"
      },
      "windows": {
        "certificateThumbprint": null,
        "digestAlgorithm": "sha256",
        "timestampUrl": ""
      }
    },
    "updater": {
      "active": true,
      "endpoints": [
        "https://github.com/yourusername/filemanager/releases/latest/download/latest.json"
      ],
      "dialog": true,
      "pubkey": "YOUR_UPDATER_PUBLIC_KEY"
    },
    "allowlist": {
      "all": false,
      "fs": {
        "readFile": true,
        "writeFile": true,
        "readDir": true,
        "copyFile": true,
        "createDir": true,
        "removeDir": true,
        "removeFile": true,
        "renameFile": true,
        "exists": true
      },
      "shell": {
        "execute": true,
        "open": true
      },
      "http": {
        "request": true,
        "scope": ["https://api.github.com/*"]
      }
    },
    "windows": [
      {
        "title": "File Manager",
        "width": 1200,
        "height": 800,
        "resizable": true,
        "fullscreen": false,
        "minWidth": 800,
        "minHeight": 600
      }
    ],
    "security": {
      "csp": "default-src 'self'"
    }
  }
}
```

#### 7.1.2 构建命令
```bash
# 开发模式
npm run tauri dev

# 构建应用（所有平台）
npm run tauri build

# 构建特定平台
npm run tauri build -- --target x86_64-pc-windows-msvc
npm run tauri build -- --target aarch64-apple-darwin
npm run tauri build -- --target x86_64-unknown-linux-gnu

# 仅构建安装包
npm run tauri build -- --bundles "msi,app,dmg,deb"
```

#### 7.1.3 安装包类型
- **Windows**：
  - `.msi`：Windows Installer（推荐）
  - `.exe`：NSIS安装程序
  - 便携版：`.zip`压缩包
- **macOS**：
  - `.app`：应用程序包
  - `.dmg`：磁盘映像
- **Linux**：
  - `.deb`：Debian/Ubuntu
  - `.AppImage`：通用Linux应用
  - `.rpm`：RedHat/Fedora

### 7.2 PostgreSQL部署方案

#### 7.2.1 本地部署（推荐）
```bash
# 使用Docker运行PostgreSQL
docker run -d \
  --name filemanager-db \
  -p 5432:5432 \
  -e POSTGRES_PASSWORD=yourpassword \
  -e POSTGRES_DB=filemanager \
  -v filemanager-data:/var/lib/postgresql/data \
  postgres:15-alpine

# 启用扩展
docker exec -it filemanager-db psql -U postgres -d filemanager -c "CREATE EXTENSION IF NOT EXISTS pg_trgm;"
```

#### 7.2.2 嵌入式方案（SQLite备选）
如果用户不想安装PostgreSQL，可以提供SQLite作为备选：
```rust
// 根据配置选择数据库类型
enum DatabaseType {
    PostgreSQL(String), // 连接字符串
    SQLite(String),     // 文件路径
}

impl DatabaseType {
    fn connect(&self) -> Result<DbConnection> {
        match self {
            DatabaseType::PostgreSQL(url) => {
                // 连接PostgreSQL
                PgConnection::establish(url)
            }
            DatabaseType::SQLite(path) => {
                // 连接SQLite
                SqliteConnection::establish(path)
            }
        }
    }
}
```

### 7.3 自动更新机制
Tauri内置自动更新功能：

```rust
// 检查更新
use tauri::Updater;

#[tauri::command]
async fn check_for_updates(app: tauri::AppHandle) -> Result<UpdateResponse, String> {
    match app.updater() {
        Ok(updater) => {
            let update = updater.check().await.map_err(|e| e.to_string())?;
            if update.is_update_available() {
                Ok(UpdateResponse {
                    available: true,
                    version: update.latest_version().to_string(),
                    notes: update.body().unwrap_or_default().to_string(),
                })
            } else {
                Ok(UpdateResponse {
                    available: false,
                    version: "".to_string(),
                    notes: "".to_string(),
                })
            }
        }
        Err(e) => Err(e.to_string()),
    }
}

// 下载并安装更新
#[tauri::command]
async fn install_update(app: tauri::AppHandle) -> Result<(), String> {
    match app.updater() {
        Ok(updater) => {
            updater.download_and_install().await.map_err(|e| e.to_string())?;
            app.restart();
            Ok(())
        }
        Err(e) => Err(e.to_string()),
    }
}
```

### 7.4 发布渠道
- **GitHub Releases**：主要发布渠道
  - 自动构建和发布（GitHub Actions）
  - 版本管理和更新通知
- **官方网站**：提供直接下载
- **包管理器**（可选）：
  - Windows：Winget、Chocolatey
  - macOS：Homebrew
  - Linux：Snap、Flatpak

### 7.5 数字签名和安全
```bash
# Windows代码签名
# 需要购买代码签名证书
signtool sign /f certificate.pfx /p password /t http://timestamp.digicert.com filemanager.exe

# macOS公证（Notarization）
xcrun notarytool submit filemanager.app --apple-id "your@email.com" --password "app-password" --team-id "TEAM_ID"

# Linux GPG签名
gpg --detach-sign --armor filemanager.AppImage
```

## 8. 性能优化策略（Rust实现）

### 8.1 内存优化（Rust特性）
```rust
// 使用智能指针和引用计数
use std::sync::Arc;
use dashmap::DashMap;

// 对象池模式
struct ConnectionPool {
    connections: Arc<DashMap<String, DbConnection>>,
}

// 延迟加载
struct LazyFileLoader {
    file_path: String,
    content: Option<Vec<u8>>,
}

impl LazyFileLoader {
    fn load(&mut self) -> &[u8] {
        if self.content.is_none() {
            self.content = Some(std::fs::read(&self.file_path).unwrap());
        }
        self.content.as_ref().unwrap()
    }
}

// 缓存策略
use lru::LruCache;
use std::num::NonZeroUsize;

struct FileCache {
    cache: Arc<DashMap<String, Arc<Vec<u8>>>>,
    lru: LruCache<String, Arc<Vec<u8>>>,
}

impl FileCache {
    fn new(capacity: usize) -> Self {
        Self {
            cache: Arc::new(DashMap::new()),
            lru: LruCache::new(NonZeroUsize::new(capacity).unwrap()),
        }
    }

    fn get(&mut self, key: &str) -> Option<Arc<Vec<u8>>> {
        // 先检查LRU缓存
        if let Some(value) = self.lru.get(key) {
            return Some(value.clone());
        }

        // 检查共享缓存
        if let Some(value) = self.cache.get(key) {
            let value = value.clone();
            self.lru.put(key.to_string(), value.clone());
            return Some(value);
        }

        None
    }
}
```

### 8.2 I/O优化（异步Rust）
```rust
// 异步文件操作
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader};

async fn read_file_async(path: &str) -> Result<Vec<u8>, std::io::Error> {
    let mut file = fs::File::open(path).await?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer).await?;
    Ok(buffer)
}

// 批量数据库写入
use diesel::insert_into;
use diesel::pg::PgConnection;

async fn batch_insert_files(
    conn: &mut PgConnection,
    files: &[File],
) -> Result<usize, diesel::result::Error> {
    use crate::schema::files::dsl::*;

    insert_into(files)
        .values(files)
        .execute(conn)
}

// 文件读取缓冲区
struct BufferedFileReader {
    reader: BufReader<fs::File>,
    buffer: [u8; 8192], // 8KB缓冲区
}

impl BufferedFileReader {
    async fn new(path: &str) -> Result<Self, std::io::Error> {
        let file = fs::File::open(path).await?;
        let reader = BufReader::new(file);
        Ok(Self {
            reader,
            buffer: [0; 8192],
        })
    }

    async fn read_chunk(&mut self) -> Result<&[u8], std::io::Error> {
        let n = self.reader.read(&mut self.buffer).await?;
        Ok(&self.buffer[..n])
    }
}
```

### 8.3 CPU优化（并行处理）
```rust
// 使用Rayon进行并行处理
use rayon::prelude::*;

struct ParallelFileProcessor;

impl ParallelFileProcessor {
    fn process_files_parallel(files: &[String]) -> Vec<FileFingerprint> {
        files
            .par_iter()
            .map(|path| {
                // 并行计算文件哈希
                Self::calculate_file_hash(path)
            })
            .collect()
    }

    fn calculate_file_hash(path: &str) -> FileFingerprint {
        // 增量哈希计算
        use sha2::{Sha256, Digest};
        use std::fs::File;
        use std::io::Read;

        let mut file = File::open(path).unwrap();
        let mut hasher = Sha256::new();
        let mut buffer = [0; 65536]; // 64KB块

        loop {
            let n = file.read(&mut buffer).unwrap();
            if n == 0 {
                break;
            }
            hasher.update(&buffer[..n]);
        }

        FileFingerprint {
            hash: format!("{:x}", hasher.finalize()),
            path: path.to_string(),
        }
    }
}

// 搜索算法优化（倒排索引）
use std::collections::HashMap;
use std::sync::RwLock;

struct InvertedIndex {
    index: Arc<RwLock<HashMap<String, Vec<FileId>>>>,
}

impl InvertedIndex {
    fn new() -> Self {
        Self {
            index: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    fn add_document(&self, doc_id: FileId, tags: &[String]) {
        let mut index = self.index.write().unwrap();
        for tag in tags {
            index
                .entry(tag.clone())
                .or_insert_with(Vec::new)
                .push(doc_id);
        }
    }

    fn search(&self, query_tags: &[String]) -> Vec<FileId> {
        let index = self.index.read().unwrap();
        let mut results = Vec::new();

        for tag in query_tags {
            if let Some(doc_ids) = index.get(tag) {
                results.extend(doc_ids);
            }
        }

        // 去重和排序
        results.sort();
        results.dedup();
        results
    }
}

// 后台任务优先级管理
use tokio::task;
use priority_queue::PriorityQueue;
use std::cmp::Reverse;

struct TaskScheduler {
    queue: Arc<tokio::sync::Mutex<PriorityQueue<Task, Reverse<u32>>>>,
}

impl TaskScheduler {
    fn new() -> Self {
        Self {
            queue: Arc::new(tokio::sync::Mutex::new(PriorityQueue::new())),
        }
    }

    async fn schedule_task(&self, task: Task, priority: u32) {
        let mut queue = self.queue.lock().await;
        queue.push(task, Reverse(priority));
    }

    async fn process_tasks(&self) {
        loop {
            let task = {
                let mut queue = self.queue.lock().await;
                queue.pop().map(|(task, _)| task)
            };

            if let Some(task) = task {
                task::spawn(async move {
                    task.execute().await;
                });
            } else {
                tokio::time::sleep(std::time::Duration::from_millis(100)).await;
            }
        }
    }
}
```

## 9. 兼容性考虑

### 9.1 跨平台支持
- **Windows**：Windows 10/11（主要目标）
- **macOS**：10.13+（可选支持）
- **Linux**：主流发行版（可选支持）

### 9.2 Windows特定考虑
#### 9.2.1 版本支持
- Windows 10 (1809+)
- Windows 11 (所有版本)
- Windows Server 2019+（可选）

#### 9.2.2 文件系统支持
- **NTFS**：完全支持（主要目标）
- **FAT32**：基础支持（文件大小限制）
- **exFAT**：基础支持
- **ReFS**：可选支持

#### 9.2.3 Windows API集成
```rust
// Windows特定功能实现
#[cfg(target_os = "windows")]
mod windows {
    use windows::{
        core::*,
        Win32::{
            Foundation::*,
            Storage::FileSystem::*,
            System::Registry::*,
        },
    };

    pub fn get_file_attributes(path: &str) -> Result<u32, windows::core::Error> {
        let wide_path: Vec<u16> = path.encode_utf16().chain(Some(0)).collect();
        unsafe {
            let attributes = GetFileAttributesW(PCWSTR(wide_path.as_ptr()));
            if attributes == INVALID_FILE_ATTRIBUTES {
                Err(Error::from_win32())
            } else {
                Ok(attributes)
            }
        }
    }

    pub fn is_hidden_file(path: &str) -> bool {
        match get_file_attributes(path) {
            Ok(attrs) => (attrs & FILE_ATTRIBUTE_HIDDEN) != 0,
            Err(_) => false,
        }
    }

    // 处理长路径（超过260字符）
    pub fn normalize_long_path(path: &str) -> String {
        if path.starts_with(r"\\?\") {
            path.to_string()
        } else if path.starts_with(r"\\") {
            // UNC路径
            format!(r"\\?\UNC\{}", &path[2..])
        } else {
            format!(r"\\?\{}", path)
        }
    }
}
```

#### 9.2.4 权限处理
- **管理员权限**：文件监控可能需要管理员权限
- **UAC处理**：正确处理用户账户控制
- **只读文件**：标记但不修改只读文件
- **网络路径**：支持UNC路径（`\\server\share`）

### 9.3 数据库兼容性
#### 9.3.1 PostgreSQL要求
- PostgreSQL 15+（推荐）
- 需要`pg_trgm`扩展（模糊搜索）
- 足够的连接数配置

#### 9.3.2 SQLite备选方案
如果用户不想安装PostgreSQL：
```rust
// 数据库抽象层
pub trait Database {
    async fn connect(&self) -> Result<DbConnection>;
    async fn execute_migration(&self) -> Result<()>;
    async fn backup(&self, backup_path: &str) -> Result<()>;
}

// PostgreSQL实现
pub struct PostgresDatabase {
    connection_string: String,
}

// SQLite实现
pub struct SqliteDatabase {
    db_path: String,
}

impl Database for SqliteDatabase {
    async fn connect(&self) -> Result<DbConnection> {
        // 使用rusqlite或sqlx连接SQLite
        Ok(())
    }

    async fn execute_migration(&self) -> Result<()> {
        // SQLite迁移
        Ok(())
    }

    async fn backup(&self, backup_path: &str) -> Result<()> {
        // SQLite备份（复制文件）
        std::fs::copy(&self.db_path, backup_path)?;
        Ok(())
    }
}
```

### 9.4 前端兼容性
#### 9.4.1 浏览器引擎
Tauri使用系统WebView：
- **Windows**：Microsoft Edge WebView2
- **macOS**：WKWebView
- **Linux**：WebKitGTK

#### 9.4.2 JavaScript/TypeScript支持
- ES2022+特性支持
- TypeScript 5.0+
- 现代CSS特性（Grid、Flexbox、CSS Variables）

#### 9.4.3 响应式设计
```css
/* 响应式布局 */
.container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1rem;
}

/* 暗色模式支持 */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #1a1a1a;
    --text-color: #ffffff;
  }
}

/* 高DPI屏幕支持 */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .icon {
    background-image: url('icon@2x.png');
  }
}
```

### 9.5 性能兼容性
#### 9.5.1 硬件要求
- **最低配置**：
  - CPU：双核 2.0GHz
  - 内存：4GB RAM
  - 存储：100MB可用空间
- **推荐配置**：
  - CPU：四核 3.0GHz+
  - 内存：8GB RAM
  - 存储：SSD，500MB可用空间

#### 9.5.2 大文件处理
- **小文件**（< 10MB）：实时处理
- **中等文件**（10MB - 100MB）：后台处理
- **大文件**（> 100MB）：增量处理，进度显示

#### 9.5.3 内存使用优化
```rust
// 内存限制配置
struct MemoryManager {
    max_memory_mb: usize,
    current_usage: Arc<AtomicUsize>,
}

impl MemoryManager {
    fn new(max_memory_mb: usize) -> Self {
        Self {
            max_memory_mb,
            current_usage: Arc::new(AtomicUsize::new(0)),
        }
    }

    fn can_allocate(&self, size_mb: usize) -> bool {
        let current = self.current_usage.load(Ordering::Relaxed);
        current + size_mb <= self.max_memory_mb
    }

    fn allocate(&self, size_mb: usize) -> Result<(), String> {
        if !self.can_allocate(size_mb) {
            return Err("内存不足".to_string());
        }
        self.current_usage.fetch_add(size_mb, Ordering::Relaxed);
        Ok(())
    }
}
```

## 10. 备选技术栈对比

| 特性 | Rust + Tauri + PostgreSQL | C# + .NET + WPF | Python + PyQt | Electron + Node.js |
|------|--------------------------|----------------|---------------|-------------------|
| **开发速度** | 中等（Rust学习曲线） | 中等 | 快速 | 快速 |
| **性能** | ⭐⭐⭐⭐⭐（极致性能） | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **内存占用** | ⭐⭐⭐⭐（~50MB） | ⭐⭐⭐⭐（~50MB） | ⭐⭐⭐（~100MB） | ⭐（~150MB+） |
| **Windows集成** | ⭐⭐⭐⭐（原生API） | ⭐⭐⭐⭐⭐（最佳） | ⭐⭐⭐ | ⭐⭐ |
| **跨平台能力** | ⭐⭐⭐⭐⭐（Tauri原生） | ⭐⭐⭐（.NET Core） | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **安装包大小** | ⭐⭐⭐⭐（~30-50MB） | ⭐⭐⭐⭐（~50MB） | ⭐⭐（~100MB+） | ⭐（~150MB+） |
| **安全性** | ⭐⭐⭐⭐⭐（内存安全） | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **维护成本** | ⭐⭐⭐（Rust专家少） | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **生态系统** | ⭐⭐⭐（成长中） | ⭐⭐⭐⭐⭐（成熟） | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **学习曲线** | ⭐⭐（较陡） | ⭐⭐⭐（中等） | ⭐⭐⭐⭐（平缓） | ⭐⭐⭐⭐（平缓） |

## 11. 推荐理由

选择 **Rust + Tauri + PostgreSQL** 方案的主要理由：

### 11.1 技术优势
1. **极致性能**：Rust提供接近C/C++的性能，无GC开销
2. **内存安全**：编译时内存安全检查，避免内存泄漏和悬垂指针
3. **现代技术栈**：Rust是增长最快的系统编程语言，未来前景好
4. **跨平台原生**：Tauri提供真正的原生应用体验，安装包小
5. **数据库强大**：PostgreSQL提供企业级数据管理能力

### 11.2 项目适配性
1. **文件系统操作**：Rust的`std::fs`和第三方库提供强大的文件操作能力
2. **并发处理**：Rust的所有权和借用系统天然适合并发编程
3. **错误处理**：Rust的`Result`和`Option`类型提供安全的错误处理
4. **零成本抽象**：高级抽象不带来运行时开销

### 11.3 开发体验
1. **工具链完善**：Cargo包管理器、rust-analyzer LSP、完善的测试框架
2. **文档优秀**：Rust有优秀的官方文档和社区资源
3. **类型系统强大**：编译时类型检查，减少运行时错误
4. **模式匹配**：强大的模式匹配简化复杂逻辑处理

### 11.4 长期考虑
1. **性能需求**：文件管理系统需要高效处理大量I/O操作
2. **内存安全**：长时间运行的应用需要避免内存泄漏
3. **跨平台潜力**：未来可能扩展到macOS/Linux
4. **学习投资**：Rust是值得投资的未来技术

### 11.5 风险缓解
1. **学习曲线**：可以通过现有JavaScript/TypeScript知识快速上手Tauri前端
2. **Rust生态**：虽然不如C#成熟，但关键库（文件系统、数据库、网络）都很完善
3. **团队技能**：作为个人项目，可以逐步学习Rust
4. **开发时间**：Rust的编译时检查可能增加开发时间，但减少调试时间

## 12. 实施建议

### 12.1 学习路径
1. **先学Tauri**：利用现有JavaScript/TypeScript知识快速构建前端
2. **逐步深入Rust**：从简单命令开始，逐步实现复杂业务逻辑
3. **实践驱动**：通过实际项目需求学习Rust特性

### 12.2 开发策略
1. **原型先行**：先用简单实现验证核心功能
2. **模块化开发**：将系统拆分为独立模块，降低复杂度
3. **测试驱动**：利用Rust强大的测试框架确保代码质量
4. **性能监控**：早期建立性能基准，持续优化

### 12.3 资源准备
1. **学习资源**：
   - [The Rust Programming Language](https://doc.rust-lang.org/book/)
   - [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
   - [Tauri Documentation](https://tauri.app/docs/)
2. **开发工具**：
   - VS Code + rust-analyzer
   - Cargo工具链
   - PostgreSQL + DBeaver
3. **社区支持**：
   - Rust官方论坛
   - Tauri Discord社区
   - Stack Overflow Rust标签

## 13. 总结

**Rust + Tauri + PostgreSQL** 是一个现代化、高性能的技术栈选择，特别适合需要处理大量文件I/O、要求高可靠性和内存安全的应用场景。虽然Rust的学习曲线较陡，但其带来的性能优势、内存安全和长期可维护性是非常有价值的投资。

对于您的文件管理系统项目，这个技术栈能够：
1. 提供极致的文件处理性能
2. 确保长时间运行的稳定性
3. 支持跨平台部署
4. 利用您现有的JavaScript/TypeScript技能
5. 学习有价值的未来技术

如果您更看重快速开发和更平缓的学习曲线，**C# + .NET + WPF** 仍然是优秀的选择。但考虑到您已经熟悉JavaScript，并且愿意学习Rust，**Rust + Tauri** 方案提供了更好的长期价值。

---
*技术方案版本：v2.0*
*创建日期：2025-12-05*
*最后更新：2025-12-05*
*主要变更：从C#方案改为Rust + Tauri + PostgreSQL方案*